<?php
 namespace Plugin\AmazonPayments\Service; use Eccube\Application; class AmazonRequestService { private $app; private $amazonSettings; private $order_prefix; public function __construct(Application $app) { $this->app = $app; $this->amazonSettings = $app['eccube.plugin.amazonpayments.repository.amazon_info']->getAmazonSettings(); $this->order_prefix = date("YmdHis") . '_'; } public function getAmazonProfile($access_token) { if (empty($access_token)) { $this->app['monolog.amazonpayments']->addInfo("ERROR: access_token not found."); return false; } $c = curl_init($this->amazonSettings['profile_api_endpoint'].'auth/o2/tokeninfo?access_token=' . urlencode($access_token)); curl_setopt($c, CURLOPT_RETURNTRANSFER, true); $r = curl_exec($c); curl_close($c); $d = json_decode($r); if ($d->aud != $this->amazonSettings['client_id']) { $this->app['monolog.amazonpayments']->addInfo("ERROR: tokeninfo response=".print_r($r,true)); return false; } $c = curl_init($this->amazonSettings['profile_api_endpoint'].'user/profile'); curl_setopt($c, CURLOPT_HTTPHEADER, array('Authorization: bearer ' . $access_token)); curl_setopt($c, CURLOPT_RETURNTRANSFER, true); $r = curl_exec($c); curl_close($c); $d = json_decode($r); if (!$d->email) { $this->app['monolog.amazonpayments']->addInfo("ERROR: profile response=".print_r($r,true)); return false; } return $d; } public function getDeliveryAddress($amazonOrderReferenceId, $addressConsentToken) { $parameters = array( "Action" => 'GetOrderReferenceDetails', "AmazonOrderReferenceId" => $amazonOrderReferenceId, "AddressConsentToken" => $addressConsentToken, ); $arrXML = $this->req($parameters); $result = array(); $result['PostalCode'] = $this->sfGetXMLTagValue($arrXML, 'PostalCode'); $result['CountryCode'] = $this->sfGetXMLTagValue($arrXML, 'CountryCode'); $result['StateOrRegion'] = $this->sfGetXMLTagValue($arrXML, 'StateOrRegion'); $result['Name'] = $this->sfGetXMLTagValue($arrXML, 'Name'); $result['AddressLine1'] = $this->sfGetXMLTagValue($arrXML, 'AddressLine1'); $result['AddressLine2'] = $this->sfGetXMLTagValue($arrXML, 'AddressLine2'); $result['AddressLine3'] = $this->sfGetXMLTagValue($arrXML, 'AddressLine3'); $result['City'] = $this->sfGetXMLTagValue($arrXML, 'City'); $result['Phone'] = $this->sfGetXMLTagValue($arrXML, 'Phone'); return $result; } public function getRequestResult($amazonOrderReferenceId, $addressConsentToken, $count=1) { $parameters = array( "Action" => 'GetOrderReferenceDetails', "AmazonOrderReferenceId" => $amazonOrderReferenceId, "AddressConsentToken" => $addressConsentToken, ); if ($count == 1) { $parameters = $this->_addRequiredParameters($parameters); } $qs = $this->_getParametersAsString($parameters); $c = curl_init(); curl_setopt($c, CURLOPT_URL, $this->amazonSettings['mws_endpoint']); curl_setopt($c, CURLOPT_POST, true); curl_setopt($c, CURLOPT_POSTFIELDS, $qs); curl_setopt($c, CURLOPT_RETURNTRANSFER, true); curl_setopt($c, CURLOPT_HTTPHEADER, array('Content-Type: application/x-www-form-urlencoded; charset=utf-8')); $r = curl_exec($c); $info = curl_getinfo($c); $errno = curl_errno($c); $error = curl_error($c); curl_close($c); if (!$r || $errno) { $this->app['monolog.amazonpayments']->addInfo("mws error: curl_error=$error ".$parameters['Action']."=".print_r($r,true)); return $r; } if ($info['http_code'] != 200) { $this->app['monolog.amazonpayments']->addInfo("mws error: http_code=".$info['http_code']." ".$parameters['Action']."=".print_r($r,true)); if (strpos($r, 'RequestThrottled') !== false) { $this->app['monolog.amazonpayments']->addInfo('aws request throttled error. action:'.$parameters['Action'] .' err_count:'.$count); if ($this->app['config']['AmazonPayments']['const']['THLOTTLE_ERR_LIMIT'] <= $count) { return false; } else { sleep($this->app['config']['AmazonPayments']['const']['THLOTTLE_SLEEP']); self::getRequestResult($amazonOrderReferenceId, $addressConsentToken, $count+1); } } else if (strpos($r, 'PaymentMethodNotAllowed') !== false) { return $this->app['config']['AmazonPayments']['const']['PAYMENT_METHOD_NOT_ALLOWED']; } else { return $r; } } return $result; } public function setOrderReferenceDetails($amazonOrderReferenceId, $order_id, $payment_total, $shop_name) { $parameters = array( "Action" => 'SetOrderReferenceDetails', "AmazonOrderReferenceId" => $amazonOrderReferenceId, 'OrderReferenceAttributes.OrderTotal.Amount' => $payment_total, 'OrderReferenceAttributes.OrderTotal.CurrencyCode' => 'JPY', 'OrderReferenceAttributes.SellerOrderAttributes.SellerOrderId' => $this->order_prefix . $order_id, 'OrderReferenceAttributes.SellerOrderAttributes.StoreName' => $shop_name, 'OrderReferenceAttributes.PlatformId' => 'A1LODGGQOBGE66', ); $arrXML = $this->req($parameters); return $arrXML; } public function confirmOrderReference($amazonOrderReferenceId) { $parameters = array( "Action" => 'ConfirmOrderReference', "AmazonOrderReferenceId" => $amazonOrderReferenceId, ); $arrXML = $this->req($parameters); return $arrXML; } public function authorize($amazonOrderReferenceId, $order_id, $payment_total) { $parameters = array("Action" => 'Authorize', "AmazonOrderReferenceId" => $amazonOrderReferenceId, 'AuthorizationReferenceId' => $this->order_prefix . $order_id, 'AuthorizationAmount.Amount' => $payment_total, 'AuthorizationAmount.CurrencyCode' => 'JPY', 'TransactionTimeout' => 0, ); if ($this->amazonSettings['sale'] == 2 && strpos($order_id, 'A') === false) { $parameters['CaptureNow'] = true; } $r = array(); $arrXML = $this->req($parameters, $r); if ($arrXML !== false) { $authorizationStatus = $this->sfGetXMLTagValue($arrXML, 'State'); if (($this->amazonSettings['sale'] != 2 && $authorizationStatus != 'Open') || $authorizationStatus == 'Declined') { $this->app['monolog.amazonpayments']->addError("mws error: authorization failed. status=$authorizationStatus ".$parameters['Action']."=".print_r($r,true)); $softDecline = $this->sfGetXMLTagValue($arrXML, 'SoftDecline'); if ($softDecline == 'true') { return 'SoftDecline'; } else { $reason_code = $this->sfGetXMLTagValue($arrXML, 'ReasonCode'); $error_code = ''; switch ($reason_code) { case 'InvalidPaymentMethod': $error_code = $this->app['config']['AmazonPayments']['const']['INVALID_PAYMENT_METHOD']; break; case 'AmazonRejected': $error_code = $this->app['config']['AmazonPayments']['const']['AMAZON_REJECTED']; break; case 'TransactionTimedOut': $error_code = $this->app['config']['AmazonPayments']['const']['TRANSACTION_TIMEDOUT']; break; default: $error_code = false; break; } return $error_code; } } } else { $this->app['monolog.amazonpayments']->addInfo("mws error: authorization failed. error=".$r); } return $arrXML; } public function capture($amazonAuthorizationId, $order_id, $captureAmount) { $parameters = array( 'Action' => 'Capture', 'AmazonAuthorizationId' => $amazonAuthorizationId, 'CaptureReferenceId' => $this->order_prefix . 'C_' . $order_id, 'CaptureAmount.Amount' => $captureAmount, 'CaptureAmount.CurrencyCode' => 'JPY', ); $r = array(); $arrXML = $this->req($parameters, $r); if ($arrXML === false) { return $r; } return $arrXML; } public function cancelOrderReference($amazonOrderReferenceId) { $parameters = array( 'Action' => 'CancelOrderReference', 'AmazonOrderReferenceId' => $amazonOrderReferenceId, ); $r = array(); $arrXML = $this->req($parameters, $r); if ($arrXML === false) { return $r; } return $arrXML; } public function refund($amazonCaptureId, $order_id, $refundAmount) { $parameters = array( 'Action' => 'Refund', 'AmazonCaptureId' => $amazonCaptureId, 'RefundReferenceId' => $this->order_prefix . 'R_' . $order_id, 'RefundAmount.Amount' => $refundAmount, 'RefundAmount.CurrencyCode' => 'JPY', ); $r = array(); $arrXML = $this->req($parameters, $r); if ($arrXML === false) { return $r; } return $arrXML; } private function req($parameters, &$r = array(), $count = 1) { if ($count == 1) { $parameters = $this->_addRequiredParameters($parameters); } $qs = $this->_getParametersAsString($parameters); $c = curl_init(); curl_setopt($c, CURLOPT_URL, $this->amazonSettings['mws_endpoint']); curl_setopt($c, CURLOPT_POST, true); curl_setopt($c, CURLOPT_POSTFIELDS, $qs); curl_setopt($c, CURLOPT_RETURNTRANSFER, true); curl_setopt($c, CURLOPT_HTTPHEADER, array('Content-Type: application/x-www-form-urlencoded; charset=utf-8')); $r = curl_exec($c); $info = curl_getinfo($c); $errno = curl_errno($c); $error = curl_error($c); curl_close($c); if (!$r || $errno) { $this->app['monolog.amazonpayments']->addInfo("mws error: curl_error=$error ".$parameters['Action']."=".print_r($r,true)); return false; } if ($info['http_code'] != 200) { $this->app['monolog.amazonpayments']->addInfo("mws error: http_code=".$info['http_code']." ".$parameters['Action']."=".print_r($r,true)); if (strpos($r, 'RequestThrottled') !== false) { $this->app['monolog.amazonpayments']->addInfo('aws request throttled error. action:'.$parameters['Action'] .' err_count:'.$count); if ($this->app['config']['AmazonPayments']['const']['THLOTTLE_ERR_LIMIT'] <= $count) { return false; } else { sleep($this->app['config']['AmazonPayments']['const']['THLOTTLE_SLEEP']); self::req($parameters, $r, $count+1); } } else if (strpos($r, 'PaymentMethodNotAllowed') !== false) { return $this->app['config']['AmazonPayments']['const']['PAYMENT_METHOD_NOT_ALLOWED']; } else { return false; } } $parser = xml_parser_create(); xml_parser_set_option($parser,XML_OPTION_TARGET_ENCODING, "UTF-8"); xml_parser_set_option($parser,XML_OPTION_SKIP_WHITE, true); $err = xml_parse_into_struct($parser,$r,$arrXML,$idx); xml_parser_free($parser); if ($this->sfExistsXMLTag($arrXML, "Action")) { $this->app['monolog.amazonpayments']->addInfo("mws error: unexpected response. ".$parameters['Action']."=".print_r($r,true)); return false; } return $arrXML; } private function _addRequiredParameters(array $parameters) { $parameters['AWSAccessKeyId'] = $this->amazonSettings['mws_access_key_id']; $parameters['Timestamp'] = $this->_getFormattedTimestamp(); $parameters['Version'] = $this->amazonSettings['service_version']; $parameters['SellerId'] = $this->amazonSettings['seller_id']; $parameters['SignatureVersion'] = 2; $parameters['SignatureMethod'] = "HmacSHA256"; $parameters['Signature'] = $this->_signParameters($parameters, $this->amazonSettings['mws_secret_access_key']); if ($this->amazonSettings['mws_auth_token'] != '') { $parameters['MWSAuthToken'] = $this->amazonSettings['mws_auth_token']; } return $parameters; } private function _getFormattedTimestamp() { return gmdate("Y-m-d\TH:i:s.\\0\\0\\0\\Z", time()); } private function _signParameters(array $parameters, $key) { $stringToSign = $this->_calculateStringToSignV2($parameters); return $this->_sign($stringToSign, $key); } private function _calculateStringToSignV2(array $parameters) { $data = 'POST'; $data .= "\n"; $endpoint = parse_url($this->amazonSettings['mws_endpoint']); $data .= $endpoint['host']; $data .= "\n"; $uri = array_key_exists('path', $endpoint) ? $endpoint['path'] : null; if (!isset($uri)) { $uri = "/"; } $uriencoded = implode("/", array_map(array($this,"_urlencode"), explode("/", $uri))); $data .= $uriencoded; $data .= "\n"; uksort($parameters, 'strcmp'); $data .= $this->_getParametersAsString($parameters); return $data; } private function _urlencode($value) { return str_replace('%7E', '~', rawurlencode($value)); } private function _getParametersAsString(array $parameters) { $queryParameters = array(); foreach ($parameters as $key => $value) { $queryParameters[] = $key . '=' . $this->_urlencode($value); } return implode('&', $queryParameters); } private function _sign($data, $key) { $hash = 'sha256'; return base64_encode(hash_hmac($hash, $data, $key, true)); } public function sfGetXMLTagValue($arrVal, $tag) { $tag = strtoupper($tag); foreach($arrVal as $array) { if($tag == $array['tag']) { return $array['value']; } } return false; } private function sfExistsXMLTag($arrVal, $tag) { $tag = strtoupper($tag); foreach($arrVal as $array) { if($tag == $array['tag']) { return ture; } } return false; } } ?>
